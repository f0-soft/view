View
=====
Осуществляет группу запросов к Flexo для подготовки данных.  
Строит персональные конфиги и шаблоны для передачи клиенту.



## Инструкция по установке
* Для запуска требуется установка `nodeunit` через `npm -g i nodeunit`
* Перед запуском провести установку зависимостей `npm install` (требуется `f0.argstype`)
* Для тестов с настоящим `rabbit`, в тесте закомментировать строку `mock = true;` 
* Перед запуском с настоящим `rabbit` следует очистить коллекции `test` и `test_join` 

### Запуск теста
```sh
nodeunit test/index.js
```

### Полная очистка mongo и redis
```sh
mongo --eval 'db.dropDatabase();' && redis-cli FLUSHALL
```



## Схема View
Позволяет определить:
* имя схемы;
* один независимый (корневой) элементы `flexo`;
* произвольное количество присоединяемых элементов `flexo`;
* функции предварительной обработки запросов к `flexo`;
* функции вычисления дополнительных параметров, запускаемые после сбора данных от `flexo`.

Пример схемы `view`
```
// Обязательно
// Имя view
exports.name: 'test';

// Необязательно
// Название файла в каталоге шаблонов
exports.template: 'test.tpl';

// Обязательно если нужна работа с данными
// Название корневой схемы flexo, к которой через связи напрямую или по пути будут присоединены другие схемы
exports.root: 'testBill';

// Необязательно
// Перечень view, которые могут дополнять запросы текущей view
exports.join: {
    testForm: {}
};

// Обязательно
// Конфиг может быть и включать в себя следующие типы данных: boolean, number, string, array, object.
// Объект в конфиге может иметь свойство `_vid`, такой объект может быть исключен из результирующего конфига
// Объект в конфиге может иметь свойства `_vid` и `_flexo`, тогда по указанному `_vid` можно обращаться к данным указанной в `_flexo` схемы
// Объект в конфиге может содержать поля `_title` и `_description`, тогда значения этих полей будут использоваться в панели администрирования
// Поле `_flexo` должно включать в себя свойство `type` - действие описано в документации контроллера
// Поле `_flexo` может включать в себя одно из свойств: `scheme` или `aggregate`
// Поле `_flexo.scheme` должно содержать массив следующего формата: [ схема_flexo, поле_flexo, поле_связи_корня, название_пути ]
// Поле `_flexo.scheme[0]` обязательно
// Поле `_flexo.scheme[1]` обязательно, кроме случая, когда в `_flexo.type` указано `delete`
// Поле `_flexo.scheme[2]` обязательно, когда `_flexo.scheme[0]` содержит не корневую flexo 
// Поле `_flexo.scheme[3]` обязательно, когда корневая схема связана со схемой `_flexo.scheme[0]` через промежуточные
// Поле `_flexo.aggregate` должно содержать объект
// Объект `_flexo.aggregate` должен иметь свойство `name`, и одно из свойств: `group`, `selector`
// Поле `_flexo.aggregate.name` должно содержать название правила агрегации из справочника агрегаций, определяемого в схеме ниже
// Поле `_flexo.aggregate.group` должно содержать объект с правилом группировки по некоторому полю заданной в справочнике агрегации коллекции
// Поле `_flexo.aggregate.selector` должно содержать название поле коллекции, по которому можно сделать сужение выборки перед агрегацией
exports.config: {
    a: 1,
    b: {
        a: 1,
        _vid: '01',
        _flexo: { type: 'read', scheme: [ 'testBill', '_id' ] },
        _title: 'ID',
        _description: 'идентификатор счета'
    },
    c: {
        a: 1,
        c: [ 1, 2, {
            _vid: '02',
            _flexo: { type:'read', scheme: [ 'test', '_id', 'test_id' ] }
        } ]
    },
    d: {
        _vid: '03',
        _flexo: {
            type: 'read',
            aggregate: {
                name: 'total',
                group: { $sum: '$amount' }
            }
        }
    }
};

// Обязательно если конфиг использует агрегацию
// Справочник агрегаций
// Правило агрегации должно содержать поля flexo и link
// Поле `flexo` должно содержать название схемы, по которой будет проводиться агрегация
// Поле link должно содержать селектор
// У свойства со значением `%id%`, значение будет заменено на _id документа, для которого делается агрегация
exports.aggregate: {
    attachmentAggregation: {
        flexo: 'testAttachment',
        link: { contract_id: '%id%' } // делает отдельный запрос по каждому id, поэтому $group._id будет содержать необходимый id
    }
};



// Необязательно
// Определяет дополнения к поисковому запросу или создаваемым документам в зависимости от роли.
// Ключи блоков find/insert содержат названия ролей.
// Можно определить правило для всех через имя '*'.
// Правило настоящей роли имеет приоритет над правилом для всех
// Если элемент запроса содержит строку '%user_id%' или '%company_id%',
// его значение будет заменено на соответствующий ID из данных текущего пользователя.
exports.access: {
    find: {
        '*' : { attachment_id: '%user_id%' }, // правило для всех
        manager: { attachment_id: '%user_id%' }, // правило для роли
        customer: { attachment_id: '%company_id%' }
    },
    insert: {
        // ключ - название роли или '*'
        // значение - объект,
        // * data - запрос
        // * lazy - говорит, имеют ли данные от пользователя приоритет над данными из правила
        boss: { data: { attachment_id: '%user_id%' }, lazy: true },
        manager: { data: { attachment_id: '%user_id%' } },
        customer: { data: { attachment_id: '%company_id%' } }
    }
};
```



## Шаблон View
Строится на сервере по персональному конфигу.  
Для шаблонизации используется модуль doT ( http://olado.github.io/doT/ ).
В шаблоне доступ к срезанному под пользователя конфигу осуществляется через переменную `it`, стандартную для этого модуля.  
Пример шаблона
```
{{ for(var prop in it) { }}
    <div>{{=prop}}</div>
{{ } }}
```



## Запросы к Rabbit
Могут быть двух типов:
* простой запрос - использует любые поля, кроме `_path`;
* сложный запрос - использует любые поля, обращается к полю `_path` через `$and` и `$in`.
Также иногда сложный запрос может обращаться к полям-массивам, отличным от `_path`, через `$in`.

```
var mongo_request = { // сложный запрос к mongo
    a: 1
    b: 2
    $and: [
        { _path: { $elemMatch: {
            c: 'k',
            f: 'l',
            i: { $in: [ 'a', 'b' ] }
        }}},
        { _path: { $elemMatch: {
            c: 'p',
            f: 'q',
            o: { $in: [ 'd', 'e' ] }
        }}},
    ]
};

var rabbit_request = [ // сложный запрос к rabbit
    'a', 1,
    'b', 2,
    '$and', [
        [ '_path', [ '$em', [
            'c', 'k',
            'f', 'l',
            'i', [ '$in', 'a', 'b' ]
        ]]],
        [ '_path', [ '$em', [
            'c', 'p',
            'f', 'q',
            'o', [ '$in', 'd', 'e' ]
        ]]]
    ]
];
```



## init( config, callback )
Выполняет инициализацию модуля

Параметры:
* `config` - объект
	* `provider` - объект, содержит методы для работы с документами (`find`,`insert`,`modify`,`delete`), иначе говоря, `flexo`
    * `views` - объект, содержит схемы `View`
    * `templatePath` - строка, содержит абсолютный путь к каталогу с шаблонами `View`
    * `[templateTimeout]` - число, время хранения шаблонов в памяти в миллисекундах
* `callback( error, module )` - функция
	* `module` - объект, контейнер функций 

Пример `views`
```
var views = {
	'test': { // имя View
		view: require(), // полный объект схемы View
		vids: { // справочник: vid -> ['flexo', 'property', 'depend_field', 'path_name']
		    'q': ['flexo1', 'field1'],
		    'w': ['flexo1', 'field2'],
		    'e': ['flexo2', 'field1', 'field3', 'path1']
		}
	}
}
```



## getTemplate( name, vids, callback )
Выполняет анализ конфига, срез конфига, срез `vid`, компоновку шаблона

Параметры:
* `name` - строка, название `View`
* `ids` - массив, содержит `vid` разрешенных элементов `View`
* `callback ( error, vids, config, template )` - функция, получает строку шаблона и объект настроек
	* `vids` - массив, содержит `vid` элементов `View` оставшихся после обработки конфига
	* `config` - объект, содержит клиентский конфиг
	* `template` - строка, содержит клиентский шаблон



## find( name, vids, request, access, callback )
Производит поиск документов по `request`.  
Каждый ключ документа - назван по `vid` элемента `View`.  
Значение каждого ключа объекта - логическое, число, строка, массив или объект.  
Поле `_link` - массив, но может отсутствовать в результирующих объектах. Элементы массива указывают на позиции документов в массиве джойнов.  

__Отступ и лимит возможны только по корневому блоку `View`.__
__Сортировка по агрегационным полям невозможна.__

Параметры:
* `name` - строка, название `View`
* `vids` - массив, содержит `vid` с которыми надо вернуть документы
* `request` - объект, запрос пользователя
    * `selector` - объект, содержит ключи названий `view` от которых идет запрос
        * `*` - объект, содержит запрос к `View`, использующий `vid`
    * `[options]` - объект,
        * `[count]` - логическое, опция запроса количества документов (корней `View`) удовлетворяющих запросу
        * `[sort]` - объект, содержит ключи `vid` и значения 1 или -1
        * `[skip]` - число, смещение ограничения количества результатов поиска
        * `[limit]` - число, ограничение количества результатов поиска
        * `[sortData]` - строка
* `access` - объект
    * `company_id` - строка, _id компании (у внутренней компании значение '0')
    * `user_id` - строка, _id пользователя
    * `role` - строка, название роли пользователя
* `callback( error, data )` - функция
    * `data` - объект
        * `result` - массив, содержит результаты поиска
    	* `[count]` - число, общее количество документов удовлетворяющих запросу
    	* `[dep]` - логическое, наличие документов, ссылающихся на данный (появляется, когда селектор производит поиск документа по _id)
    	* `[sortData]` - строка

Пример `result`
```
/*
В примере в корне содержится 1 документ.
Он связан с 2 документами из 1-го джойна. Значение агрегации содержится прямо в документе массива корней.
Оба документа из 1-го джойна связаны с одним и тем же документом из 2-го джойна.
*/ 
result = [ [
    // (0) массив корней

    { 'vid1': 'a', 'vid2': 'b',
        'vid6': 42,
        _link: [ 0, 1 ] // заначения _link указывают на позиции в массиве джойнов
    }
], [
    // (1) массив джойнов

    { 'vid3': 'c', 'vid4': 'd', _link: [ 2 ] },  // заначения _link указывают на позиции в массиве джойнов
    { 'vid3': 'e', 'vid4': 'f', _link: [ 2 ] },
    
    { 'vid5': 'g' }
] ];
```



## insert( name, vids, request, access, callback )
Производит сохранение документов через соответствующие `flexo`

Параметры:
* `name` - строка, название `View`
* `vids` - массив, содержит `vid` с которыми надо вернуть сохраненные документы (возвращает только корневые элементы)
* `request` - массив
	* `document` - объект, содержит документ `View`
* `access` - объект
    * `company_id` - строка, _id компании (у внутренней компании значение '0')
    * `user_id` - строка, _id пользователя
    * `role` - строка, название роли пользователя
* `callback( error, documents )` - функция
    * `documents` - массив
        * `document` - объект, содержит поля документа `View`



## modify( name, request, access, callback )
Производит изменение документов через соответствующие `flexo`

Параметры:
* `name` - строка, название `View`
* `request` - массив
	* `query` - объект, содержит запрос на изменение документа
	    * `selector` - объект, содержит поля `_id` и `tsUpdate` в виде `vid` для каждого блока `Flexo` если его поле есть в `properties`
	    * `properties` - объект, содержит новые значение полей `View`
* `access` - объект
    * `company_id` - строка, _id компании (у внутренней компании значение '0')
    * `user_id` - строка, _id пользователя
    * `role` - строка, название роли пользователя
* `callback( error, documents )` - функция
	* `documents` - массив
	    * `document` - объект, содержит поля `_id` и `tsUpdate` в виде `vid`



## delete( name, request, access, callback )
Производит удаление документов через соответствующие `flexo`

Параметры:
* `name` - строка, название `View`
* `request` - массив, содержит селекторы на удаление документов
	* `selector` - объект, содержит поля `_id` и `tsUpdate` в виде `vid`
* `access` - объект
    * `company_id` - строка, _id компании (у внутренней компании значение '0')
    * `user_id` - строка, _id пользователя
    * `role` - строка, название роли пользователя
* `callback( error, documents )` - функция
	* `documents` - массив
	    * `document` - объект, содержит поле `_id` в виде `vid`
